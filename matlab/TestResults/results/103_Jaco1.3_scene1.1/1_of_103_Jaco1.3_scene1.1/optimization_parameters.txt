%%%;;

%% GENERAL PARAMETERS
% for other strucutures
time_struct.ti = 0;
time_struct.tf = 20;
time_struct.step = 0.001;

%% for simulation 
time_sym_struct = time_struct;
time_sym_struct.step = 0.001; 
% define the type of integration of the sytem of differential equation
fixed_step = false; %true;
torque_saturation =20; % high value no saturation

%% TASK PARAMETERS
%name_dat = 'sere/LBR4p5.0_scene5_UF_repellers_on_elbow__atrtactive_point_on_ee_fit5_SERE';
%name_dat = 'sere/LBR4p9.0_scene5_GHC_table_and_an_one_attractive_point_and_posture_task_SERE';
%name_dat = 'LBR4p8.0_scene9_GHC_test_wall_and_two_attractive_point';
%name_dat = 'LBR4p11.0_scene9_UF_mulitple_task_stability_Null_space_projectors';
%name_dat = 'LBR4p10.0_scene10_UF_lemniscate';
%name_dat = 'LBR4p12.0_scene0_UF_test_elastic_reference';
name_dat = 'Jaco1.3_scene1.1';
%name_dat = 'LBR4p2.2_scene2_generalization';
path=LoadParameters(name_dat);
load(path);

%% SCENARIO
name_scenario = 'jaco_scenario1.1';%'lbr_scenario_2_gen' lbr_scenario2; %lbr_scenario5.1,'lbr_scenario9','lbr_scenario10';

%% STARTING CONDITION FOR SIMULATION
% TODO generalize for multichain
qi{1} = qz;
%qi{1} = zeros(1,chains.GetNumLinks(1)); %stretched arm
qdi{1} = zeros(1,chains.GetNumLinks(1));
options= [];
simulator_type = {'rbt'};

%% Parameters Dependant on the type of controller

%%%EOF%%%;;

% REPELLER PARAMETERS
% scenario dependant
rep_subchain = [7];
rep_target_link{1} = rep_subchain;
rep_type = {'cartesian_x'};
rep_mask {1,1}=[1,1,1]; 
rep_type_of_J_rep = {'DirectionCartesian'};
for ii=1:chains.GetNumChains()
    chain_dof(ii) = chains.GetNumLinks(ii);
end



%CONTROLLER PARAMETERS
% the metric change between regularized and not regularized because in the
% regularized case i have to do N^(-1) 
% not regularized case i have N^(-1/2)
metric = {'M','M','M','M'};  % ex: if N = M^(-1) so N^(-1/2) = (M^(-1))^(-1/2) = M^(1/2);        


kp = [50,10,5,700]; % row vector one for each chain 50,1,5
kd = [2*sqrt(kp),2*sqrt(kp),2*sqrt(kp),2*sqrt(kp)];

for i= 1:chains.GetNumChains()
   for par = 1:chains.GetNumTasks(i)
       K_p = kp(i,par)*eye(size(dim_of_task{i,par},1));  
       K_d = kd(i,par)*eye(size(dim_of_task{i,par},1)); 
       Kp{i,par} = K_p;
       Kd{i,par} = K_d;
   end
   
end



%%%EOF